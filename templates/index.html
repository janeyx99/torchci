<!DOCTYPE html>

{% import 'macros.jinja' as macros %}

<link rel="stylesheet" href="{{ url_for('static', filename='common.css') }}">

<style>
  .dialog-target {
    cursor: pointer;
  }

  .job-dialog {
    background-color: lightgray;
    padding: 5px 0;
    border-radius: 6px;

    position: absolute;
    z-index: 1;

    white-space: nowrap;
  }

  th {
    text-align: left;
  }

  /* code to roatate the workflow name headers */
  .job-header {
    font-family: sans-serif;
    height: 220px;
    white-space: nowrap;
    font-family: sans-serif;
  }

  .job-header__name {
    transform:
      translate(10px, 100px) rotate(315deg);
    width: 10px;
    font-weight: 400;
    font-size: .8em;
  }

  .regular-header {
    font-family: sans-serif;
    vertical-align: bottom;
  }

  .job-metadata {
    white-space: nowrap;
    font-family: sans-serif;
  }
</style>

<html>

<head>
  <meta charset="UTF-8" />
  <title>Janky HUD</title>

  <!-- scripts to get display times in local timezone
    TODO this can be done natively with a little extra work
   -->
  <script src="https://unpkg.com/dayjs@1.8.21/dayjs.min.js"></script>
  <script src="https://unpkg.com/dayjs@1.8.21/plugin/utc.js"></script>
  <script>dayjs.extend(window.dayjs_plugin_utc)</script>
  <script>
    customElements.define("time-formatted", class extends HTMLElement {
      connectedCallback() {
        let time = dayjs(this.getAttribute('timestamp')).local();
        if (dayjs().isSame(time, 'day')) {
          // "6:55 PM"
          this.innerHTML = time.format('h:mm A')
        } else {
          // "Wed, Dec 8"
          this.innerHTML = time.format('ddd, MMM D')
        }
      }
    });
  </script>
</head>
<h1>PyTorch Janky HUD</h1>

<body>
  <table id="hud-table" style="display:none">
    <thead>
      <tr>
        <th class="regular-header">Time</th>
        <th class="regular-header">SHA</th>
        <th class="regular-header">Commit</th>
        <th class="regular-header">PR</th>

        {% for name in names %}
        <th class="job-header">
          <div class="job-header__name">{{name}}</div>
        </th>
        {% endfor %}
      </tr>
    </thead>

    <tbody>
      {% for (time, sha, commit_url, commit_message, pr_num), jobs in sha_grid.items() %}
      <tr>
        <!-- Time -->
        <td class="job-metadata">
          <time-formatted timestamp='{{time}}'></time-formatted>
        </td>

        <!-- SHA -->
        <td class="job-metadata"><a href={{commit_url}}> {{ sha[:7] }} </a></td>

        <!-- Commit title -->
        <td class="job-metadata"> <a href="commit/{{sha}}">{{commit_message}}</a> </td>

        <!-- Pull Request link -->
        <td class="job-metadata">
          {% if pr_num %}
          <a href=https://github.com/pytorch/pytorch/pull/{{pr_num}}>#{{pr_num}}</a>
          {% endif %}
        </td>

        <!-- All the jobs -->
        {% for job in jobs %}
        <td class="dialog-target" job-id={{job.id}}>
          <div class="conclusion">
            {% if job %}
            {{ macros.emoji_for_conclusion(job.conclusion) }}
            {% else %}
            <span class="conclusion-none">O</span>
            {% endif %}
          </div>
        </td>
        {% endfor %}
      </tr>
      {% endfor %}
    </tbody>
  </table>

  <script>
    // Optimization to avoid needless re-flowing as the table HTML loads. Our
    // table is static and very large, so we can just hide it until we have
    // all the data then render it once.
    // See: https://patdavid.net/2019/02/displaying-a-big-html-table/
    document.getElementById("hud-table").style.display = null;
  </script>

  <script>
    function newDialog(jobTarget) {
      const th = jobTarget.closest("table").querySelector(`th:nth-child(${jobTarget.cellIndex + 1})`);
      const jobName = th.querySelector('.job-header__name').innerHTML
      const newDialog = document.createElement("div")
      newDialog.className = "job-dialog";
      newDialog.innerHTML = jobName;

      const box = jobTarget.getBoundingClientRect();
      newDialog.style.left = box.x + 20 + "px";
      newDialog.style.top = box.y + 20 + "px";
      document.body.append(newDialog);
      return newDialog;
    }

    function jobMouseOver(event) {
      const elem = event.currentTarget;
      const existingDialog = document.querySelector('.job-dialog');
      if (existingDialog !== null) {
        return;
      }
      // Find the corresponding header name (cellIndex+1 because nth-child is 1-indexed);
      newDialog(elem);
    }

    function jobMouseLeave(event) {
      const elem = event.currentTarget;
      const existingDialog = document.querySelector('.job-dialog');
      if (existingDialog === null || existingDialog.getAttribute("pinned") === "true") {
        return;
      }
      existingDialog.remove();
    }

    function jobClick(event) {
      const elem = event.currentTarget;
      let dialog = document.querySelector('.job-dialog');

      if (dialog === null) {
        dialog = newDialog(elem);
      }
      // const newDialog = document.createElement("div")
      // newDialog.className = "job-dialog";
      dialog.setAttribute("pinned", "true");
      dialog.innerHTML += "<div class='loading'>Loadingâ€¦</div>";
      // elem.append(newDialog);

      const id = elem.getAttribute("job-id");
      let response = fetch("job_dialog/" + id)
        .then(response => response.json())
        .then(data => {
          dialog.querySelector(".loading").remove();
          dialog.innerHTML = data.html;
        },
          error => {
            dialog.innerHTML = "Error loading job data";
          }).then(() => {
            // Add an event listener to close the dialog when the user clicks outside
            document.addEventListener('click', function cb(event) {
              if (!dialog.contains(event.target)) {
                dialog.remove();
                // Remove this listener when the dialog is removed.
                event.currentTarget.removeEventListener(event.type, cb);
              }
            });
          });
    }
    document.querySelectorAll(".dialog-target")
      .forEach(function (element) {
        element.addEventListener('click', jobClick)
        element.addEventListener('mouseover', jobMouseOver)
        element.addEventListener('mouseleave', jobMouseLeave)
      });
  </script>
</body>

</html>
